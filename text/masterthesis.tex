\documentclass[
a4paper, 							% Papierformat
%10pt,								% Schriftgrˆﬂe (12pt, 11pt (Standard))
%twoside,							% Doppelseiten
titlepage,						% Titelei auf eigener Seite
%normalheadings,			% ‹berschriften etwas kleiner (smallheadings)
%idxtotoc,						% Index im Inhaltsverzeichnis
%liststotoc,					% Abb.- und Tab.verzeichnis im Inhalt
%bibtotoc,						% Literaturverzeichnis im Inhalt
%leqno,   						% Nummerierung von Gleichungen links
%fleqn,								% Ausgabe von Gleichungen linksb¸ndig
%draft								% ¸berlangen Zeilen in Ausgabe gekennzeichnet
]
{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tipa}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm,includeheadfoot]{geometry}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{listings} \lstset{numbers=left, numberstyle=\tiny, numbersep=5pt, xleftmargin=1cm, xrightmargin=1cm, frame=topline} \lstset{language=Java}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}


\begin{document}



\thispagestyle{empty}
\begin{titlepage}
\begin{figure}[t]
	\centering
  \includegraphics[width=80mm]{images/HsKaLogoKlein.png}
	\vspace{2.5cm}
\end{figure}
\begin{center}
\title{Master-Thesis}
\textbf{\huge{Master-Thesis}} \\[0.5cm]
\textbf{Visual Studio Erweiterung zur statischen Code-Analyse} \\[4cm]
\textbf{andrena objetcs ag} \\[0.25cm]
\author{Manuel Naujoks} Manuel Naujoks\\[2.5cm]
Betreut durch \\[0.25cm] 
Prof. Dr. Thomas Fuchﬂ \\[2.5cm]
Bischweier, den \today
\end{center}
\end{titlepage}



\pagenumbering{roman}
\setcounter{page}{1}
\begin{center}\textbf{\large Erkl‰rung}\\[1cm]\end{center}
Hiermit versichere ich, dass ich die vorliegende Arbeit selbstst‰ndig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe, dass alle Stellen der Arbeit, die wˆrtlich oder sinngem‰ﬂ aus anderen Quellen ¸bernommen wurden, als solche kenntlich gemacht sind und dass die Arbeit in gleicher oder ‰hnlicher Form noch keiner Pr¸fungsbehˆrde vorgelegt wurde.
\\[4\baselineskip]
Bischweier, den \today \\
Manuel Naujoks
\newpage



\chapter*{Zusammenfassung}
Im Rahmen dieser Master-Thesis soll eine Visual Studio Erweiterung entwickelt werden, die direktes Entwickler-Feedback anhand von Software-Metriken geben kann. Dabei dient das Plugin Usus f¸r Eclipse als Vorlage, welches bereits existiert. Die zu erstellende Erweiterung soll eine statische Code-Analyse von .NET-Projekten in Visual Stuido 2010 durchf¸hren und f¸r andrena relevante Code-Metriken berechnen kˆnnen.
\newline
Die zu entwickelnde Erweiterung soll genutzt werden kˆnnen, um Software-Entwickler aktiv zu unterst¸tzen "`Clean code"' zu schreiben. Eine ‰hnliche Lˆsung zu Microsofts Achievements Extension mit Achievements in Bezug auf clean code best practices w‰re denkbar. Dazu soll eine Evaluierung anhand von Beispielaufgaben aus einem andrena-Kurs zum Thema Refaktorisierung bearbeitet und die Ver‰nderung in den Metriken entsprechend erfasst und dokumentiert werden.
\newline
Weiterhin soll in einer Metrik-Analyse nach Heuristiken oder Regeln mit statischer Signifikanz gesucht werden, die eventuell guten von schlechtem Code unterscheiden kˆnnen. Lassen sich hier Muster beziehungsweise Strukturen aufzeigen? Ein Indiz hierf¸r ist, dass die Metriken oft einer Exponentialverteilung folgen. Dabei soll untersucht werden, ob und wenn mˆglich wie sich dies auf den Software Qualit‰ts Index (SQI) von andrena abbilden l‰sst.
\newpage



\chapter*{Abstract}
Objective of this master thesis is the development of a Visual Studio Extension that is capable of providing direct development feedback based on software metrics. The Eclipse plugin Usus, which already exists, is going to be used as orientation. The extension that is developed shall be able to perform static code analysis of .NET projects in Visual Studio 2010 in order to calculate the code metrics that are relevant for andrena.
\newline
As far as feedback is concerned, the extension shall be able to actively support developers to write "`clean code"'. A similar solution to Microsofts Achievements Extension could likely be found with achievements based on common clean code best practices. Therefore an evaluation with sample exercises of an andrena course on the topic of refactoring is done and the variation in the metrics is detected and documented.
\newline
Another metric analysis is performed in order to find heuristics or rules with static significance, which might be able to distinguish good code from bad code. Are there detectable patterns? One thing might be that metrics often follow an exponential distribution. An analysis shall show whether it is possible and if yes, how this can be mapped to the Software Quality Index (SQI) of andrena.
\newpage




\tableofcontents




\chapter{Einf¸hrung}
\pagenumbering{arabic}
\setcounter{page}{1}
bla bla bla Softwarequalit‰t
bla bla bla Metriken
bla bla bla Entwicklerfeedback
bla bla bla ‹bersicht ¸ber Codebasis
bla bla bla direkt in Visual Studio
bla bla bla

\section{andrena objects ag}
Diese Master-Thesis wird bei dem Software-Unternehmen andrena objects ag durchgef¸hrt. bla bla bla.

\section{Aufbau der Thesis}
bla bla bla.




\chapter{Grundlagen}
In diesem Kapitel sollen die Grundlagen vermittelt werden, die f¸r ein Verst‰ndnis einer mit Quellcode arbeitenden Erweiterung f¸r Visual Studio erforderlich sind. Dazu wird in Abschnitt \ref{sec:generalbasics} zun‰chst auf allgemeine Grundlagen wie Quellcode, sowie Entwicklungsumgebungen eingegangen. Anschlieﬂend werden in Abschnitt \ref{sec:technicalbasics} die technischen Grundlagen vorgestellt.


\section{Allgemeine Grundlagen}
In diesem Abschnitt wird in Unterabschnitt \ref{subsec:cleancode} zun‰chst auf die Clean Code Idee sowie manche Prinzipien eingegangen. Anschlieﬂend wird in Unterabschnitt \ref{subsec:eclipse} das Programm Eclipse vorgestellt. In Unterabschnitt \ref{subsec:visualstudio} wird abschlieﬂend auf das Umfeld der Erweiterung eingegangen wird, die im Rahmen dieser Master-Thesis entwickelt werden soll. Dabei handelt es sich um das Entwicklungswerkzeug Visual Studio.
\label{sec:generalbasics}

\subsection{Clean Code}
\label{subsec:cleancode}
Ein Softwaresystem wird in Form von Quellcode erstellt. Dieser Code wird anschlieﬂend kompiliert um eine ausf¸hrbares Programm zu erhalten. Robert C. Martin beschreibt Code in seinem Clean Code Buch als Sprache, in der wir die Anforderungen an die Software maschinenlesbar zum Ausdruck bringen \cite{CleanCode}. Weiter beschreibt er in seinem Buch Prinzipien und "`Best Practices"', die das Erstellen von verst‰ndlicherem und wartbareren Quellcode unterst¸tzen. Die selben Prinzipien wurden auch von Ralf Westphal und Stefan Lieser aufgegriffen und im Rahmen eines Wertesystems mit sieben Graden vorgestellt \cite{CleanCodeDeveloper}. Martin's Clean Code Buch bleibt auch f¸r Westphal und Lieser die grundlegende Lekt¸re.
\paragraph{}
Die Prinzipien und Best Practices der Clean Code Bewegung umfassen viele Aspekte, die bereits durch Kent Beck in seinem Buch ¸ber die Methodik \textit{Extreme Programming} (XP) \cite{XP} eingef¸hrt wurden. Drei wichtige Bestandteile von XP, die ebenfalls in den Graden des Clean Code Wertesystems von Westphal und Lieser auftreten, sind die folgenden.
\begin{description}
\item[Automatisiertes Testen] ist eine der wichtigsten Praktiken in der Clean Code Bewegung. Nach Robert C. Martin ist es die Aufgabe eines Entwicklers keinen Schaden in einem Softwaresystem anzurichten. Damit meint er Schaden an der Funktionalit‰t und Schaden an der Struktur der Anwendung. Beides kann mit automatisierten Testf‰llen sichergestellt werden.
\item[St‰ndiges Refactoring] ist der effektivste Schutz gegen Schaden an der Struktur eines Softwaresystems bedingt durch evolution‰res Wachstum und vielen Anpassungen. Durch Tests kann dabei sichergestellt werden, dass Umstrukturierungen den Funktionsumfang nicht beeintr‰chtigen. Martin Fowler beschreibt solches Refactoring in seinem Buch \cite{Refactoring}
\item[Schnelle Code Reviews] sind eine weitere Voraussetzung um Clean Code entwickeln zu kˆnnen. Der entscheidende Punkt ist das Feedback. Je schneller der Entwickler Feedback bekommt um so fr¸her kˆnnen Probleme im Quellcode erkannt und mit relativ wenig Aufwand korrigiert werden.
\end{description}

\subsection{Eclipse}
\label{subsec:eclipse}
Eclipse ist eine integrierte Entwicklungsumgebung (IDE) der Eclipse Foundation. Eclipse ist eine kostenfreies open source Programm und wird haupts‰chlich f¸r die Entwicklung von Anwendungen mit der Programmiersprache Java verwendet.
\newline \textbf{todo: info link}

\subsection{Visual Studio}
\label{subsec:visualstudio}
Visual Studio ist eine integrierte Entwicklungsumgebung von Microsoft. Im Gegensatz zu Eclipse ist Visual Studio ab der Professional Version ein kommerzielles Produkt. Die Entwicklung f¸r das .NET-Framework von Microsoft wird haupts‰chlich mit Visual Studio durchgef¸hrt. Die bekanntesten und am weitersten verbreiteten Sprachen f¸r das .NET-Framework sind C\# und Viusal Basic .NET.
\newline \textbf{todo: info link}


\section{Technische Grundlagen}
\label{sec:technicalbasics}
In diesem Abschnitt werden die technischen Grundlagen erl‰utert. Dazu wird in Unterabschnitt \ref{subsec:oo} zun‰chst der Begriff der Objektorientierung eingef¸hrt, bevor in Unterabschnitt \ref{subsec:graphs} auf Graphen n‰her eingegangen wird. Abschlieﬂend wird in Unterabschnitt \ref{subsec:staticcodeanalysis} das Konzept der statischen Code-Analyse vorgestellt.

\subsection{Objektorientierung}
\label{subsec:oo}
Die Objektorientierung als Methode ermˆglicht laut Benrd Oestereich die hohe Komplexit‰t von Softwaresystemen zu beherrschen \cite{OOSE}. Das ist mˆglich, da diese Methode die Dinge der realen Welt als Objekte sieht und dadurch die Problemdom‰ne verst‰ndlich und anschaulich macht. Ein objektorientiertes Softwaresystem besteht aus den folgenden vier wesentlichen Komponenten.
\begin{description}
\item[Klasse] kommt aus dem lateinischen von \textit{classis} und bedeutet "`Aufgebot"'. Damit ist laut Oestereich eine Teilmenge von Objekten der gleichen Struktur gemeint. Eine Klasse ist folglich auch der Typ aller seiner Objekte.
\item[Objekt] kommt ebenfalls aus dem lateinischen von \textit{obicere} und bedeutet "`entgegenhalten"'. Bernd Oestereich beschreibt es als "`Gegenstand der Erkenntnis und Wahrnehmung, des Denkens und Handelns"' und bezieht sich dabei auf das Brockhaus Lexikon. Ein Objekt ist eine Instanz einer Klasse.
\item[Attribut] kommt auch aus dem lateinischen von \textit{attributum} und bedeutet "`das Beigef¸gte"', was einer Eigenschaft oder einem Kennzeichen einer Sache entspricht. Die Daten, die ein Objekt ausmachen, werden anhand von Attributen gespeichert, auf die von den Operationen des Objekts aus zugegriffen werden kann. Attribute werden auch als Felder bezeichnet und lassen sich in Klassen-Felder und Instanz-Felder unterscheiden. Klassen-Felder kˆnnen von allen Objekten der Klasse gemeinsam genutzt werden, w‰hrend Instanz-Felder unterschiedliche Werte f¸r konkrete Objekte haben kˆnnen.
\item[Operation] kommt aus dem lateinischen von \textit{operatio} und bedeutet "`Handlung"'. Eine konkrete Aktion, die anhand einer definierten Vorschrift durchgef¸hrt wird bezeichnet Oestereich in diesem Sinne als Operation. Das Verhalten von Objekten wird anhand ihrer Operationen festgelegt. Andere Bezeichnungen f¸r Operation ist Funktion oder Methode. Methoden lassen sich in Klassen-Methoden und Instanz-Methoden aufteilen. Klassen-Methoden kˆnnen nicht auf die Instanz-Felder sondern nur auf die Klassen-Felder zugreifen. Instanz-Methoden kˆnnen auf Instanz-Felder und auf Klassenfelder zugreifen.
\item[Paket] wird von Oestereich als eine Ansammlung von Modellelementen bezeichnet. Dabei sind Modellelemente Klassen oder andere Pakete und dienen der besseren Strukturierung des Systems.
\end{description}
Zus‰tzlich beschreibt Oerstereich zwei weitere Mittel von objektorientierten Softwaresystemen, die der Abstraktion dienen und die es erlauben irrelevant Dinge wegzulassen.
\begin{description}
\item[Assoziation] kommt aus dem lateinischen von \textit{associare} und bedeutet "`verbinden"'. Nach Oestereich entspricht dies einer \textit{Hat-eine-Beziehung} und gibt an, dass eine Klasse mit einer anderen Klasse zusammenarbeitet. Objekte der Klasse kˆnnen auf Objekte der verbundenen Klasse zugreifen. Damit ist die Klasse, von der die Assoziation ausgeht, von der anderen Klasse abh‰ngig. Anders ausgedr¸ckt hat diese Klasse eine Abh‰ngigkeit von der anderen.
\item[Vererbung] entspricht einer \textit{Ist-ein-Beziehung} und gibt an, dass eine Klasse das Verhalten und die Struktur einer anderen Klasse erbt oder spezialisiert. Ein Objekt der erbenden Klasse ist damit auch ein Objekt der gerbten Klasse und hat somit auch eine Abh‰ngigkeit von ihr.
\end{description}
Mit diesen sieben Konzepten kann eine Softwaresystem objektorientiert beschrieben werden.

\subsection{Graphentheorie}
\label{subsec:graphs}
Heiko Kˆrner beschreibt einen Graph in seinem Skript \cite{GraphAlgorithms} als Zweiertupel \begin{math}G = (V, E)\end{math}. Der erste Wert, $V$, ist eine endliche Menge an Knoten und der zweite, $E$, ist eine endliche Menge an Kanten zwischen diesen Knoten. Eine Kante ist ein Paar aus \begin{math}V \times V\end{math} und beinhaltet die beiden Knoten, die sie verbindet. Kˆrner unterscheidet in gerichtete und ungerichtete Graphen. Bei letzterem verbindet eine Kante die Knoten in beiden Richtungen, wobei eine gerichtete Kante die Verbindungsrichtung anhand der Knoten-Reihenfolge im Kanten-Tupel vorgibt. Weiter definiert Kˆrner einen Baum als zusammenh‰ngenden azyklischen Graph, indem jeder Knoten von einem Wurzelknoten aus erreichbar ist.

\subsection{Statische Code-Analyse}
\label{subsec:staticcodeanalysis}
bla bla bla abstrakter Syntaxbaum
\begin{description}
\item[Metrik] bla bla bla Softwarequalit‰t
\item[Auspr‰gung der Metrik] bla bla bla Softwarequalit‰t
\item[Statistik der Metrik] bla bla bla Bewertung
\end{description}
bla bla bla NDepend
bla bla bla Visual Studio Code Metrics




\chapter{Anforderungen}
\label{chap:requirements}
In diesem Kapitel werden die Anforderungen an die Visual Studio Erweiterung zur statischen Code-Anaylse beschrieben, die im Rahmen dieser Master-Thesis entwickelt werden soll. Dabei werden die Anforderungen in einem agilen Kontext bestimmt und in Form von Sprint 0 wie in Scrum\footnote[1]{\url{http://www.pmscrum.com/blog/2011/06/10-things-do-sprint-0}} definiert. Dieses Kapitel gibt damit eine Antwort auf die Frage, was gemacht werden soll.


\section{Interessenvertreter}
\label{sec:stakeholder}
Die Interessenvertreter (engl. \textit{Stakeholder}) im Kontext dieser Master-Thesis sind Gruppen von Personen, die einen Einfluss auf Anforderungen des Systems haben kˆnnen. Die folgenden vier Gruppen wurden daf¸r identifiziert.
\begin{description}
\item[andrena objects ag] als Arbeitgeber stellt das Umfeld dar, indem das Projekt durchgef¸hrt und das System implementiert wird. Sie legt Wert auf agile Softwareentwicklung und mˆchte Entwicklungsprozesse und Praktiken gewinnbringend einsetzen. Die andrena objects ag hat bereits ein Plugin zur statischen Code-Analyse f¸r Java und Eclipse entwickelt und mˆchte ihren Entwicklern ein ‰hnliches Programm auch f¸r die .NET-Umgebung zur Verf¸gung stellen kˆnnen.
\item[Leser dieser Thesis] haben ebenfalls ein Interesse an dem zu entwickelnden Produkt, das haupts‰chlich theoretischer Natur ist. Sie haben einen Informatik-artigen Hintergrund und mˆchten einen Einblick in die Algorithmen und die Implementierungsdetails s‰mtlicher implementierten Aspekte des Systems erhalten.
\item[.NET-Entwickler mit wenig Erfahrung] arbeiten an kleineren Codebasen und wollen auf einfache Weise einen ‹berblick ¸ber Problemf‰lle des Systems behalten. Mithilfe des Systems wollen sie diese rechtzeitig beseitigen und sicherstellen, dass dadurch keine neuen Probleme entstehen.
\item[.NET-Entwickler mit viel Erfahrung] arbeiten an groﬂen und komplizierten Codebasen und mˆchten das System einsetzen um Tendenzen im System zu erkennen und Spezialf‰lle zu analysieren. Auch sie wollen einen besseren ‹berblick erhalten und das System aus mˆglichst vielen verschiedenen Perspektiven sehen.
\item[.NET-Entwickler (Clean Coder)] legen sehr viel Wert auf Quellcode, der mˆglichst einfach zu verstehen ist und damit schnell an neue Anforderungen angepasst werden kann. Sie erwarten von dem System Feedback und Unterst¸tzung bei der Entwicklung von sauberem Code. Auﬂerdem mˆchten sie auf Stellen im Code hingewiesen werden, die nicht ihren Vorstellungen entsprechen.
\end{description}
Die Beschreibungen der Interessengruppen sind grob und allgemein gehalten, w‰hrend versucht wurde, die direkten Bed¸rfnisse der jeweiligen Gruppe zu benennen. Nat¸rlich ist die Erkl‰rung damit nicht vollst‰ndig oder exklusiv. So kann beispielsweise auch ein erfahrener .NET-Entwickler ein Interesse an Clean Code haben.


\section{Ziele}
\label{sec:goals}
Nachdem die beteiligten Interessengruppen definiert wurden, werden in diesem Abschnitt die Ziele des zu entwickelnden Systems beschrieben. Peter Hruschka und Chris Rupp erkl‰ren in ihrem Buch \cite{AgileSEUML} ein Ziel als "`ein erstrebenswerter Zustand"' in der Zukunft, den es zu erreichen gilt. Damit ist ein Ziel eine abstrakte Form einer Anforderung an das System, die sich auch in einem agilen Projekt nicht so schnell ‰ndert wie spezielle Anforderungen.

\subsection{Einsicht in die Codebasis}
Groﬂe Entwicklungsprojekte haben eine groﬂe Codebasis, die es den Entwicklern erschwert Aussagen ¸ber den Quellcode des Systems zu machen. Mithilfe statischer Code-Analyse kann eine Einsicht in diesen Quellcode gew‰hrleistet und so zum Vorteil aller Interessenvertreter genutzt werden. Eigenschaften des Quellcodes werden als kˆnnen als Metriken berechnet und bewertet werden. Dieses Ziel ist erreicht, sobald ein Entwickler, der die Codebasis nicht oder nur unzureichend kennt, Eigenschaften des Codes erkennen und darauf reagieren kann.

\subsection{Erkennen von Problemf‰llen}
In einer vorhandenen Codebasis besteht die Gefahr, den ‹berblick ¸ber Problemf‰lle zu verlieren. Ein Problem kann beispielsweise eine Klasse sein, die zu viele Abh‰ngigkeiten zu anderen Klassen hat, oder eine Methode, die zu viel Funktionalit‰t besitzt. Das Erkennen und Anzeigen dieser Stellen ist ein Vorteil, von dem alle Interessenvertreter profitieren kˆnnen, und der es ermˆglicht, Schwachstellen systematisch zu entfernen. Dieses Ziel ist erreicht, sobald ein Entwickler, der die Codebasis nicht oder nur unzureichend kennt, Probleme im Code erkennen und darauf reagieren kann.

\subsection{Fˆrderung von Clean Code}
Das Entwickeln von Code kann auf eine sehr r¸cksichtslose Art und Weise geschehen, sodass sp‰tere Anpassungen nur schwer vorzunehmen sind. Durch Feedback und Unterst¸tzung w‰hrend der Programmierung kann die Entwicklung von Clean Code gefˆrdert werden, was zu einer Codebasis f¸hrt, die flexibler auf Anpassungen reagieren kann. Dieses Ziel ist erreicht, sobald ein Entwickler mehr Clean Code Praktiken beachtet und einh‰lt, als er dies ohne Unterst¸tzung des Systems getan h‰tte.

\subsection{Bewertung der Software-Qualit‰t}
Eine bestehende Codebasis zu bewerten erfordert detaillierte Kenntnis ¸ber alle Klassen, deren Interaktionen und vielem mehr. Auﬂerdem muss eine menschliche Bewertung manuell jedes mal neu erfolgen und ist dabei subjektiv. Eine automatisierte Bewertung anhand von Regeln und Gewichtungen, die auf Erfahrungen basieren, kann die Bewertung optimieren und einem Entwickler jederzeit und ohne viel Aufwand eine Qualit‰tspr¸fung ermˆglichen. Dieses Ziel ist erreicht, sobald ein Entwickler, der die Codebasis nicht oder nur unzureichend kennt, die Qualit‰t des Quellcodes ermitteln und mit anderen Systemen vergleichen kann.


\section{Architektur}
In diesem Abschnitt wird die grundlegende Architektur des zu entwickelnden Systems erl‰utert. Im Rahmen dieser Master-Thesis soll ein System entwickelt werden, dass die in Abschnitt \ref{sec:goals} genannten Ziele erreicht. Zus‰tzlich soll dieses System als Erweiterung in Visual Studio laufen und den Quelltext (kompiliert und/oder unkompiliert) in einer .NET-Sprache, wie beispielsweise C\#, analysieren. Abbildung \ref{fig:architecture} zeigt die beiden Komponenten \textit{Visualisierung} und \textit{statische Code-Analyse}, um die es sich im weiteren Verlauf handeln wird.
\begin{figure}[h]
	\centering
		\includegraphics[width=12cm]{images/architektur.jpg}
	\caption{Grobe Architektur des Systems}
	\label{fig:architecture}
\end{figure}
Die Komponente, die die statische Code-Analyse durchf¸hrt, verwendet drei Aktionen, die einem kompletten Analyse-Prozess entsprechen. Die schwarzen Pfeile symbolisieren dabei Zugriffe auf Daten. Die Aktion \textit{Berechnung} betrachtet das Softwaresystem und kann daf¸r auf den Quellcode und das erzeugte Kompilat zugreifen. Das Ergebnis dieser Betrachtung wird in Form von Metriken in einer Datenbank gespeichert und stellt Daten f¸r die Aktion \textit{Gewichtung} bereit. Diese gewichtet die Daten und erzeugt Statistiken, die ebenfalls in der Datenbank hinterlegt werden. Die Aktion \textit{Bewertung} versucht anhand der gewichteten Daten eine Aussage ¸ber die Qualit‰t des Softwaresystems zu treffen. Nachdem diese drei Aktionen abgelaufen sind, ist der Analyse-Prozess beendet. Die Komponente \textit{Visualisierung}, die in Visual Studio ausgef¸hrt wird, kann diesen Analyse-Prozess starten und auf dessen Daten zugreifen. Sie zeigt die berechneten Metriken in geeigneten Kontexten an und gibt basierend auf der Bewertung ein entsprechendes Entwickler-Feedback. Dieses Feedback entsteht dabei genau dort, wo der Quellcode entstanden ist, der von dem Analyse-Prozess verarbeitet wurde. Nach einer entsprechenden Ver‰nderung des Quelltext kann der Prozess erneut gestartet werden, um auch diese Ver‰nderung zu analysieren. So entsteht theoretisch ein kontinuierlicher Verbesserungskreislauf. Dieser Zyklus wird durch die breiten transparenten Pfeile angezeigt und entspricht dem Informationsfluss in dieser Umgebung.


\section{Use Cases}
Aus den in Abschnitt \ref{sec:goals} definierten Zielen dieses Projekts lassen sich zun‰chst vier Anwendungsf‰lle bestimmen, die in Abbildung \ref{fig:usecases} dargestellt sind.
\begin{figure}[h]
	\centering
		\includegraphics[width=12cm]{images/usecases.jpg}
	\caption{Anwendungsf‰lle des Systems}
	\label{fig:usecases}
\end{figure}
Die Akteure entsprechen ungef‰hr den in Abschnitt \ref{sec:stakeholder} definierten Interessenvertretern. Der Akteur \textit{.NET-Entwickler} entspricht dem Interessenvertreter mit wenig .NET Erfahrung und dessen Interaktionen mit dem System werden von dem Entwickler mit viel Erfahrung, beziehungsweise Clean Code Interessen, erweitert. Die Interessenvertreter \textit{andrena objects ag} und \textit{Leser des Thesis} haben keine direkte Interaktion mit dem System und werden bei der Betrachtung der Use Cases ignoriert. Es ist ebenfalls zu sehen, dass der Anwendungsfall \textit{Code-Metriken bestimmen} alle anderen Anwendungsf‰lle direkt oder indirekt erg‰nzt. Damit ist er ein entscheidender Bestandteil des Systems, wenn nicht sogar der wichtigste.


\section{Produkt-Backlog}
\label{sec:productbacklog}
Die Anwendungsf‰lle lassen sich in User Stories (\textit{Anwendererz‰hlungen}) unterteilen. Abbildung \ref{fig:productbacklog} zeit diese Aufteilung in der horizontalen und die Verteilung auf geplante Sprints in der vertikalen Dimension. Dieses zwei-dimensionale Backlog stellt die konkreten Anforderungen aus Benutzersicht an das komplette System dar.
\begin{figure}[h]
	\centering
		\includegraphics[width=17cm]{images/backlog.jpg}
	\caption{Produkt-Backlog des Systems}
	\label{fig:productbacklog}
\end{figure}
Die User Stories sind allgemein gehalten, da auf ein groﬂes Design vor der Implementierung aus Agilit‰tsgr¸nden verzichtet wurde. Pro Sprint werden die User Stories dann in konkrete Entwicklungs-Aufgaben unterteilt. Die Begr¸ndung jeder Story wurde nicht explizit aufgeschrieben, da die Beziehung zu den Use Cases und damit den Zielen aus Abschnitt \ref{sec:goals} erhalten und somit offensichtlich geblieben ist. Eine Priorisierung ist ebenfalls implizit durch das Aufteilen auf die Sprints entstanden, sodass eine explizite Business Value Analyse nicht notwendig ist. Die Sprint-Planung ist vorl‰ufig und ‰ndert sich eventuell w‰hrend der Durchf¸hrung des Projekts, wenn neue Use Cases und User Stories dazukommen oder andere wegfallen. Zum Zeitpunkt dieser Planung lassen sich die bereits gefunden User Stories in wahrscheinlich f¸nf Sprints implementieren. Was die Abnahmekriterien und Akzeptanztests jeder Anwendererz‰hlung betreffen, so wurde auch hier kein Mehrwert in der expliziten Definition gesehen, da pro Story schnell ein exemplarischer Test durchgef¸hrt werden kann, der zeigt, ob das Ziel erreicht wurde. Daf¸r kann beispielsweise ein Benutzertest mit einer Person aus der jeweiligen Interessengruppe repr‰sentativ durchgef¸hrt werden.




\chapter{Vorgehensweise}
Nach dem die Anforderungen an das System, das in dieser Masther-Thesis entwickelt werden soll, in Kapitel \ref{chap:requirements} definiert wurden, wird in diesem Kapitel die grobe Vorgehensweise beschrieben. Dabei wird eine grobe Zeitplanung vorgestellt. Dieses Kapitel gibt damit eine Antwort auf die Frage, wie die Anforderungen realisiert werden sollen. Abbildung \ref{fig:plan_table} zeigt die zeitliche Aufteilung der Master-Thesis, w‰hrend Abbildung \ref{fig:plan_gantt} das dazugehˆrige Gant-Chart darstellt. Die Thesis besteht aus einem praktischen und einen theoretischen Teil.


\section{Praktischer Teil}
Der praktische Teil besteht aus einer Evaluationsphase und der eigentlichen Implementierungsphase. W‰hrend der Evaluierung werden verschiedene Technologien betrachtet, mit denen eine statische Code-Analyse durchgef¸hrt werden kann. Das Ergebnis der Evaluierung wird die Grundlage der n‰chsten Phase darstellen. In der zweiten Phase werden die User Stories aus Abschnitt \ref{sec:productbacklog} im Rahmen der Visual Studio-Erweiterung zur statischen Code-Analyse in f¸nf zweiwˆchigen Sprints implementiert.


\section{Theoretischer Teil}
bla bla bla
\begin{enumerate} 
\item Planungsphase
\item Zusammenfassung der Evaluation und der f¸nf Sprints
\item Fallbeispiel Andrena-Kurs
\item Analyse von Metrik-Verteilungen, Mapping von Metriken und Verteilungswerten auf den Andrena Software Quality Index (SQI)
\end{enumerate}
bla bla bla

\begin{figure}[h]
	\centering
		\includegraphics[width=15cm]{images/planningTable.png}
	\caption{Projektplan Tabelle}
	\label{fig:plan_table}
\end{figure}

\begin{figure}[h]
	\centering
		\includegraphics[width=15cm]{images/planningGantt.png}
	\caption{Projektplan Gantt-Chart}
	\label{fig:plan_gantt}
\end{figure}




\chapter{Usus}
Das Wort \textit{usus} kommt aus dem lateinischen und bedeutet "`das, was ¸blich ist"'. In diesem Kapitel wird das Usus Plugin f¸r die Java Entwicklungsumgebung Eclipse \cite{UsusEclipsePlugin} vorgestellt, sowie auf die Metriken, die es berechnet, eingegangen. Der Bedeutung entsprechend 


\section{Eclipse Plugin}
Das Usus Plugin f¸r Eclipse l‰sst sich ¸ber den Men¸-Eintrag \texttt{Help / Install New Software} installieren, indem eine neue Software Site mit der Url \url{http://projectusus.googlecode.com/svn/updates/} hinzugef¸gt und anschlieﬂend \emph{Project Usus} ausgew‰hlt wird. Nach der Installation steht die \emph{Project Usus perspective} zur Verf¸gung, die die folgenden Fenster enth‰lt.

\subsection{Usus Cockpit}
In diesem Fenster werden die Usus Metriken angezeigt, die f¸r alle Projekte, die Usus betrachtet, gelten. Zus‰tzlich wird der Trend pro Metrik dargestellt, also ob sich die Auspr‰gung der Metrik verbessert oder verschlechtert hat. Die Verbesserung wird dabei zwischen zwei erstellten Snapshots gemessen, die entweder manuell oder durch einen neuen Speichervorgang ausgelˆst werden kˆnnen.
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm]{images/usus_cockpit.png}
	\caption{Usus Cockpit zeigt ‹bersicht ¸ber alle Projekte}
	\label{fig:usus_cockpit}
\end{figure}
Die in Abbildung \ref{fig:usus_cockpit} dargestellten Statistiken der Metriken errechnen sich aus der Aggregation der Paket-, Klassen- oder Methoden-Eigenschaften.

\subsection{Usus Info}
Dieses Fenster l‰sst sich im Kontext einer Methode oder einer Klasse ˆffnen und zeigt Metriken, die anhand der Eigenschaften des Kontextes ermittelt werden kˆnnen.
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm]{images/usus_info.png}
	\caption{Usus Info zeigt ‹bersicht ¸ber eine Methode oder Klasse}
	\label{fig:usus_info}
\end{figure}
Das in Abbildung \ref{fig:usus_info} gezeigte Info-Fenster l‰sst sich mit \texttt{Ctrl-U} ˆffnen und mit \texttt{Esc} wieder schlieﬂen.

\subsection{Usus Hotspots}
\label{subsec:usushotspots}
Dieses Fenster zeigt sogenannte Hotspots, also Stellen im Quellcode, dessen Metriken definierte Grenze oder einen Schwellwert ¸berschreiten. Hotspots lassen sich f¸r jede Metrik definieren, die im Usus Cockpit angezeigt wird. Zus‰tzlich wird der Trend pro Hotspot gezeigt, also ob sich der Hotspot verbessert oder verschlechtert.
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm]{images/usus_hotspots.png}
	\caption{Usus Hotspots zeigt die Stellen im Code, die eine besondere Metrikauspr‰gung haben}
	\label{fig:usus_hotspots}
\end{figure}
Das in Abbildung \ref{fig:usus_hotspots} gezeigte Hotspot-Fenster zeigt Hotspots immer nur f¸r eine Metrik an. Der Wechsel zu einer anderen Hotspot-Metrik erfolgt ¸ber einen Doppelklick auf die Metrikanzeige im Usus Cockpit. ‹ber einen Doppelklick auf einen Hotspot l‰sst sich entweder zu der dazugehˆrigen Methode im Quelltext oder dem entsprechende Paket oder der Klasse in einem der beiden Usus Graph Ansichten navigieren.

\subsection{Usus Histogram}
Dieses Fenster zeigt die absolute H‰ufigkeitsverteilung der Auspr‰gungen einer Metrik ¸ber alle Projekte an, die Usus betrachtet. Die verwendete Metrik wird dabei auf der der x-Achse angezeigt, w‰hrend die Anzahl der Auspr‰gungen auf der y-Achse dargestellt wird. Die Verteilung l‰sst sich f¸r eine der Metriken definieren, die im Usus Cockpit angezeigt werden.
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm]{images/usus_histogram.png}
	\caption{Usus Histogram zeigt die statistische Verteilung der Auspr‰gungen der definierten Metrik}
	\label{fig:usus_histogram}
\end{figure}
Das in Abbildung \ref{fig:usus_histogram} gezeigte Histogramm-Fenster zeigt die Verteilung der Metrik an, die zuvor ¸ber einen Einfachklick im Usus Cockpit markiert wurde. Es zeigt immer nur die Daten f¸r eine Metrik an. Die Ansicht kann vergrˆﬂert, verkleinert, skaliert und als Grafik gespeichert werden.

\subsection{Usus Class Graph \& Usus Package Graph}
\label{subsec:ususgraphs}
Dieses Fenster zeigt die Abh‰ngigkeiten der betrachteten Projekte entweder auf Klassenebene oder auf Paketebene an. Auf Paketebene lassen sich optional nur die Pakete anzeigen, die sich in einem Zyklus von Abh‰ngigkeiten zu anderen Paketen befinden. Auf Klassenebene lassen sich optional nur die Klassen anzeigen, die ¸ber eine Abh‰ngigkeit ¸ber Paketgrenzen hinweg verf¸gen. Dabei werden auch nur eben diese Paket¸bergreifenden Abh‰ngigkeiten angezeigt.
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm]{images/usus_graph.png}
	\caption{Usus Graph Schaubilder zeigen die Abh‰ngigkeiten der Klassen oder Pakete voneinander an}
	\label{fig:usus_graph}
\end{figure}
Das in Abbildung \ref{fig:usus_graph} dargestellte Fenster besteht aus zwei Karteikarten. Eine Karteikarte zeigt den Usus Class Graph, w‰hrend die andere den Usus Package Graph darstellt. Zwischen den beiden Ansichten kann beliebig gewechselt werden. Die Knoten in den Graphen lassen sich mit der Maus frei positionieren. Zus‰tzlich lassen sich die Graphen-Darstellungen auch automatisch anordnen.


\section{Metriken}
In den Fenstern Usus Cockpit und Usus Info zeit das Eclipse Plugin die Werte verschiedener Metriken an. Das Usus Info Fenster zeigt im Kontext einer Methode neben den Metriken, die es zus‰tzlich f¸r die Klasse anzeigt auch Methoden-Metriken. In diesem Abschnitt wird daher zuerst auf die Metriken eingegangen, die das Usus Plugin f¸r Methoden berechnet, bevor die Klassen-Metriken n‰her betrachtet werden. Abschlieﬂend werden die Usus Cockpit Metriken beschrieben.

\subsection{Pro Methode}
Wenn das Usus Info Fenster im Kontext einer Methode geˆffnet wird, wird die zyklomatische Komplexit‰t sowie die L‰nge der Methode dargestellt.
\subsubsection{Zyklomatische Komplexit‰t}
\label{subsubsec:cyclomaticcomplexity}
Die Metrik \textit{Cyclomatic Complexity} wurde von Thomas J. McCabe vorgestellt \cite{AComplexityMeasure} um Methoden anhand von linear unabh‰ngigen Ablaufpfaden in Bezug auf Komplexit‰t zu bewerten. McCabe bezieht sich in seinem Artikel auf die Graphentheorie und errechnet die Komplexit‰t eines Ablaufgraphen wie folgt.
\begin{equation}
v(G) = e - n + 2p
\label{eq:cyclomaticcomplexity1}
\end{equation}
\begin{eqnarray*}
G&=&\text{Ablaufgraph}\\
v(G)&=&\text{zyklomatische Komplexit‰t von $G$}\\
e&=&\text{Anzahl Kanten im Ablaufgraphen $G$}\\
n&=&\text{Anzahl Knoten im Ablaufgraphen $G$}\\
p&=&\text{Anzahl Zusammenhangskomponenten in $G$}\\
\label{eq:cyclomaticcomplexity1agenda}
\end{eqnarray*}
Ernest Wallm¸ller beschreibt die zyklomatische Komplexit‰t in seinem Buch \cite{SoftwareQMPraxis} auch als Anzahl aller entscheidungstreffenden Stellen in der Methode. Im Falle einer Verkettung von bin‰ren Entscheidungen zu logischen Ausdr¸cken z‰hlt jede Entscheidung als eine solche Stelle. Diese einfachere Rechnung ergibt sich als
\begin{equation}
	v(G) = 1 + \Big( \sum_{b\text{ }\in\text{ } \displaystyle Bs(G)} 1 \Big)
\label{eq:cyclomaticcomplexity2}
\end{equation}
wobei $Bs(G)$ die Menge aller bin‰ren Entscheidungen im Ablaufgraphen $G$ darstellt. Voraussetzung f¸r diese Rechnung ist, das die Methode nur einen Eingang und nur einen Ausgang besitzt. Der Quellcode in Listing \ref{listing:simpleifs} soll die Grundlage f¸r eine demonstrative Berechnung der zyklomatischen Komplexit‰t darstellen.
\begin{lstlisting}[caption={Einfache if-Verschachtelung},label={listing:simpleifs}]
public void doSomething() {
   if (condition1) {
      if (condition2 || condition3)
         do1();
   }
}
\end{lstlisting}
Nach Formel \ref{eq:cyclomaticcomplexity2} ergeben sich drei Entscheidungsstellen, welche durch die drei bin‰ren Bedingungen dargestellt werden. Die zyklomatische Komplexit‰t entspricht damit \begin{math}v(G) = 1 + 3 = 4\end{math}.
\begin{figure}[h]
	\centering
		\includegraphics[width=9cm]{images/cc.jpg}
	\caption{Ablaufgraph G des Quellcodes \ref{listing:simpleifs}}
	\label{fig:ccsamplegraph}
\end{figure}
Die Berechnung anhand Formel \ref{eq:cyclomaticcomplexity1} basiert auf der Struktur des Ablaufgraphen, der in Abbildung \ref{fig:ccsamplegraph} dargestellt ist. Hier entspricht die zyklomatische Komplexit‰t \begin{math}v(G) = 10 - 8 + 2 * 1 = 4\end{math}. Die Ergebnisse beider Rechnungen sind identisch. Die Eigenschaften einer Methode, die f¸r die Berechnung der \textit{Cyclomatic Complexity}-Metrik erforderlich sind, sind also entweder die Anzahl der bin‰ren Entscheidungen oder der vollst‰ndige Ablaufgraph.
\subsubsection{Methodenl‰nge}
\label{subsubsec:methodlength}
Die L‰nge einer Methode kann auf unterschiedliche Weise ermittelt werden. Eine Unterscheidung der Mˆglichkeiten wird von Mark Lorenz und Jeff Kidds in \cite{OOSMetrics} vorgenommen.
\begin{description}
\item[Anzahl Code-Zeilen] (engl. Lines of code) entspricht der tats‰chlichen Anzahl an Zeilenumbr¸chen ohne leere Zeilen und Kommentarzeilen. Diese L‰ngenangabe ist stark vom Entwicklerstil abh‰ngig und kann sich daher unterschiedlich auspr‰gen, je nachdem wie beispielsweise eine Parameterliste umgebrochen wird.
\item[Anzahl der Anweisungen] (engl. Number of statements) entspricht nach Lorenz und Kidds einer stabileren L‰ngenangabe. Eine Anweisung ist jeder durch ein Semikolon abgeschlossene Ausdruck sowie Bedingungs- und Wiederholungsanweisungen.
\end{description} 
Die im Usus Info Fenster angezeigte Methodenl‰nge entspricht der Anzahl der Anweisungen der Methode. Eine Berechnung kann daher ¸ber die Aufsummierung der Semikola und der if-, switch-, for-, while- und try-catch-Anweisungen erfolgen.

\subsection{Pro Klasse}
Wenn das Usus Info Fenster im Kontext einer Klasse geˆffnet wird, wird die Klassengrˆﬂe sowie die kumulierte Komponentenabh‰ngigkeit der Klasse dargestellt.
\subsubsection{Klassengrˆﬂe}
\label{subsubsec:classsize}
ƒhnlich der Methodenl‰nge l‰sst sich auch die Grˆﬂe einer Klasse auf verschiedene Weise berechnen. Lorenz und Jeff unterscheiden auch hier mehrere Mˆglichkeiten \cite{OOSMetrics}.
\begin{description}
\item[Anzahl der Methoden] erlaubt es Klassen zu erkennen, die zu viel oder zu wenig Funktionen erf¸llen. Weitere Unterscheidungsmˆglichkeiten sind Methoden in Klassen- und Instanz-Methoden aufzuteilen oder Methoden anhand der Sichtbarkeit zu klassifizieren. Ein Konstruktor w¸rde sich wie eine statische Methode, also eine Klassen-Methode, verhalten.
\item[Anzahl der Felder] erlaubt es Klassen zu erkennen, die zu viel Informationen verwalten. Auch hier ist eine weitere Unterteilung in Klassen- und Instanz-Felder mˆglich. Die Sichtbarkeit der Felder erlaubt eine weitere Einschr‰nkung.
\end{description} 
Das Usus Info Fenster zeigt als Klassengrˆﬂe die Anzahl der Instanz-Methoden, der Klassen-Methoden sowie der Konstruktoren an. Dabei wird die Sichtbarkeit der Methode oder des Konstruktors nicht ber¸cksichtigt. Das Usus Plugin fokussiert damit auf die Funktion der Klassen und nicht auf die Information und das Wissen einer Klasse, welches in den Feldern liegt. Die Klassengrˆﬂe kann also berechnet werden, wenn alle Methoden und Konstruktoren einer Klasse ermittelt werden kˆnnen.
\subsubsection{Kumulierte Komponentenabh‰ngigkeit}
\label{subsubsec:ccd}
Die Metrik \textit{Cumulative Component Dependency} ist laut Peter Grogono \cite{SoftwareQControl} eine Metrik, die f¸r Systeme und Untersysteme ermittelt wird. Dabei werden f¸r jede Klasse (Komponente) in diesem System die Anzahl der Klassen ermittelt, von denen die betrachtete Klasse direkt und indirekt abh‰ngt. Eine Klasse ist immer auch von sich selber abh‰ngig. Marc Philipp und Nicole Rauch bezeichnen diese Abh‰ngigkeiten in ihrem Artikel \cite{EclipseMagUsus} als reflexsiv und transitiv. Anschlieﬂend werden die Abh‰ngigkeiten aller betrachteten Klassen aufsummiert und ergeben den CCD-Wert des Systems. In dem Usus Info Fenster wird der Abh‰ngigkeitswert einer betrachteten Klasse als \textit{CCD (of class)} bezeichnet. Um die Anzahl der Klassen zu bestimmen, von denen eine betrachtete Klasse abh‰ngig ist, ist mindestens der vollst‰ndige Abh‰ngigkeitsgraph der Klasse erforderlich. Mit einem Durchmusterungsalgorithmus kann die Erreichbarkeitsmenge (Reach-Menge) der Klasse (Startknoten) in diesem Abh‰ngigkeitsgraph ermittelt werden. Heiko Kˆrner beschreibt in seinem Skript \cite{GraphAlgorithms} die beiden Algorithmen \textit{BFS} (Breadth First Search) und \textit{DFS} (Depth First Search) f¸r diesen Zweck.
\begin{figure}[h]
	\centering
		\includegraphics[width=11cm]{images/ccd.jpg}
	\caption{Abh‰ngigkeitsgraph einer Klasse mit aufsummierten Abh‰ngigkeiten}
	\label{fig:ccd}
\end{figure}
Abbildung \ref{fig:ccd} zeigt sieben Klassen, die in einer hierarchischen Abh‰ngigkeitsstruktur stehen. Offensichtlich ist Klasse A von allen anderen Klassen abh‰ngig und hat damit den CCD-Wert sieben. Dies entspricht der Kardinalit‰t der Reach-Menge von A, \begin{math}\{A,B,C,D,E,F,G\}\end{math}, die ermittelt wird, indem BFS oder DFS mit Klasse A als Startknoten im Abh‰ngigkeitsgraph gestartet wird. Dabei werden die durch den Algorithmus markierten Knoten als Ergebnis des Algorithmus behandelt. Bei dem Abh‰ngigkeitsgraph muss es sich nicht um einen Baum handeln.
\begin{equation}
	ccd(C) = | DFS(dG, C) |
\label{eq:cumulativecomponentdependencyofclass}
\end{equation}
\begin{eqnarray*}
dG&=&\text{Abh‰ngigkeitsgraph des Systems}\\
C&=&\text{Klasse im System}\in dG\\
ccd(C)&=&\text{CCD-Wert der Klasse } C\\
\label{eq:cumulativecomponentdependencyofclassagenda}
\end{eqnarray*}
Formel \ref{eq:cumulativecomponentdependencyofclass} zeigt die Berechnungsvorschrift unter Verwendung des \textit{DFS}-Algorithmus. Die Berechnung des CCD-Werts einer Klasse kann also durchgef¸hrt werden, sobald ein Abh‰ngigkeitsgraph erzeugt werden kann. Um einen solchen Graphen zu erzeugen m¸ssen die direkten Abh‰ngigkeiten einer Klasse ermittelt werden kˆnnen. Jede Klasse wird dann einem Knoten zugeordnet und jede Abh‰ngigkeit einer gerichteten Kante. Eine grafische Darstellung (siehe Unterabschnitt \ref{subsec:ususgraphs}) ist dann ebenfalls mˆglich. Die direkten Abh‰ngigkeiten einer Klasse kˆnnen bestimmt werden, wenn die Typen aller Felder, Methodenparameter, Oberklasse und Interfaces sowie s‰mtlicher Methodenaufrufe entfernter Klassen identifiziert werden kˆnnen. Abh‰ngigkeiten zu Klassen, wie beispielsweise \texttt{String} oder \texttt{Object}, die im Basis-Framework definiert sind, kˆnnen ignoriert werden.

\subsection{Projekt¸bergreifend}
Neben den Metriken, die Usus f¸r Methoden und Klassen berechnet, werden im Usus Cockpit Statistiken zu der Codebasis angezeigt. Daf¸r werden die ermittelten Metriken bewertet, wie es Marc Philipp und Nicole Rauch in ihrem Artikel \cite{EclipseMagUsus} beschreiben. In diesem Unterabschnitt werden die verscheiden Statistiken vorgestellt und auf ihre Bewertung eingegangen. Weiterhin werden die Schwellwerte der Statistiken definiert, anhand derer eine Klasse, Methode oder Paket als Hotspot (siehe Unter-Unterabschnitt \ref{subsec:usushotspots}) eingestuft wird.
\subsubsection{Durchschnittliche kumulierte Komponentenabh‰ngigkeit}
Die Metrik \textit{Average Component Dependency} ist laut Peter Grogono \cite{SoftwareQControl} wie \textit{Cumulative Component Dependency} eine Metrik, die f¸r Systeme und Untersysteme ermittelt wird. Dabei wird der Mittelwert des CCD-Werts des Systems wie in Formel \ref{eq:averagecomponentdependency1} berechnet, wobei $n$ die Anzahl der Klassen im System ist.
\begin{equation}
	acd = \frac{ccd}{n}
\label{eq:averagecomponentdependency1}
\end{equation}
Da Usus die CCD-Werte nicht f¸r Systeme oder Untersysteme ermittelt, sondern die CCD-Werte der Klassen bestimmt ohne sie aufzusummieren (siehe Unter-Unterabschnitt \ref{subsubsec:ccd}), kann der ACD-Wert anhand einer Menge von Klassen $Cs$ berechnet werden, wie in Formel \ref{eq:averagecomponentdependency2} dargestellt. Die Rechnung ist ‰quivalent zu Formel \ref{eq:averagecomponentdependency1}.
\begin{equation}
	acd(Cs) = \frac{\displaystyle \sum_{C\text{ }\in\text{ }Cs} ccd(C)}{|Cs|}
\label{eq:averagecomponentdependency2}
\end{equation}
Peter Grogono beschreibt die Bedeutung des ACD-Werts als durchschnittliche Anzahl an Komponenten, die durch eine ƒnderung einer Komponente betroffen sind und eventuell ebenfalls ge‰ndert werden m¸ssen. Der ACD-Wert wird im Usus Cockpit als Statistik in Prozent angezeigt. Dazu wird nochmal der Mittelwert ¸ber die betrachteten Klassen gebildet, wie in Formel \ref{eq:averagecomponentdependency3} zu sehen ist und der Bewertungsfunktion von Philipp und Rauch entspricht.
\begin{equation}
	acd'(Cs) = \frac{acd(Cs)}{|Cs|}
\label{eq:averagecomponentdependency3}
\end{equation}
Eine Klasse wird von Usus dann als Hotspot betrachtet, wenn ihr CCD-Wert ¸ber einer Schwelle liegt, die von der Projektgrˆﬂe abh‰ngig ist. Die Projektgrˆﬂe wird dabei an der Anzahl der Klassen festgelegt. Anhand der Tooltip-Erkl‰rung im Usus Cockpit liegt diese Schwelle f¸r kleine Projekte bei 15\% der Klassenanzahl, w‰hrend bei groﬂen Projekten 5\% der Klassenanzahl verwendet wird. Daf¸r haben Philipp und Rauch Formel \ref{eq:averagecomponentdependency4} mithilfe von Erfahrungswerten definiert um die Berechnung des CCD-Schwellwert $L_{ccd}$ anhand der Menge aller Klassen $Cs$ im System durchf¸hren zu kˆnnen.
\begin{equation}
	L_{ccd}(Cs) = \frac{1,5}{2^{\displaystyle (\log_{5} |Cs|)}}
\label{eq:averagecomponentdependency4}
\end{equation}
\subsubsection{Durchschnittliche Klassengrˆﬂe}
Eine Klasse wird von Usus als Hotspot gesehen, sobald die in Unter-Unterabschnitt \ref{subsubsec:classsize} beschriebene Klassengrˆﬂe den Schwellwert 12 ¸bersteigt. Das haben Philipp und Rauch festgelegt. Die im Usus Cockpit angezeigte durchschnittliche Klassengrˆﬂe betrachtet nur die Klassen, die bereits als Hotspot markiert wurden. Das liegt an der Bewertungsfunktion $rating_{cs}$ von Philipp und Rauch, die in Formel \ref{eq:averageclasssize1} angegeben ist.
\begin{equation}
	rating_{cs}(cs) = 
	\begin{cases}
		\displaystyle	\frac{1}{12 * cs} - 1, & \text{wenn }cs > 12\\
		0, & \text{sonst}\\
	\end{cases}
\label{eq:averageclasssize1}
\end{equation}
Die Bewertungsfunktion der Klassengrˆﬂe $cs$ ist direkt von dem Schwellwert 12 abh‰ngig und bewertet alle Klassen, dessen Grˆﬂe 12 oder weniger betr‰gt mit 0. Um die durchschnittliche Klassengrˆﬂe $acs$ einer Menge von Klassen $Cs$ zu berechnen, bildet Usus den Mittelwert aller bewerteter Klassengrˆﬂen. Dazu wird die Formel \ref{eq:averageclasssize2} verwendet.
\begin{equation}
	acs(Cs) = \frac{\displaystyle \sum_{C\text{ }\in\text{ }Cs} rating_{cs}(C)}{|Cs|}
\label{eq:averageclasssize2}
\end{equation}
Dabei gehen die mit 0 bewerteten Klassengrˆﬂen ebenfalls in die Durchschnittsberechnung ein.
\subsubsection{Durchschnittliche zyklomatische Komplexit‰t}
Die Berechnung der durchschnittlichen zyklomatischen Komplexit‰t findet auf ‰hnliche Weise statt. Philipp und Rauch haben hier den Schwellwert 4 gew‰hlt. Damit werden Methoden ignoriert, die vier oder weniger unabh‰ngige Ablaufpfade besitzen oder anders ausgedr¸ckt, weniger als vier verschiedene Entscheidungen treffen. Die Bewertungsfunktion $rating_{cc}$ eines wie in Unter-Unterabschnitt \ref{subsubsec:cyclomaticcomplexity} berechneten zyklomatischen Komplexit‰ts-Wert sieht damit folgendermaﬂen aus.
\begin{equation}
	rating_{cc}(cc) = 
	\begin{cases}
		\displaystyle	\frac{1}{4 * cc} - 1, & \text{wenn }cc > 4\\
		0, & \text{sonst}\\
	\end{cases}
\label{eq:averagecyclomaticcomplexity}
\end{equation}
Anschlieﬂend kann der Mittelwert der bewerteten Komplexit‰ten gebildet werden, indem durch die Anzahl der Methoden dividiert wird.
\subsubsection{Durchschnittliche Methodenl‰nge}
Auch die Berechnung der durchschnittlichen Methodenl‰nge findet ‰hnlich statt. Der Schwellwert f¸r die in Unter-Unterabschnitt \ref{subsubsec:methodlength} berechnete Metrik wurde hier auf 9 festgelegt. Methoden mit 9 oder weniger Anweisungen werden damit ignoriert. Die Bewertungsfunktion $rating_{ml}$ sieht dann folgendermaﬂen aus.
\begin{equation}
	rating_{ml}(ml) = 
	\begin{cases}
		\displaystyle	\frac{1}{9 * ml} - 1, & \text{wenn }ml > 9\\
		0, & \text{sonst}\\
	\end{cases}
\label{eq:averagemethodlength}
\end{equation}
Aus den bewerteten L‰ngen kann dann wieder der Mittelwert berechnet werden, indem durch die Anzahl der Methoden dividiert wird.
\subsubsection{Anzahl nicht-statischer ˆffentlicher Felder}
Wenn eine Klasse mindestens ein ˆffentliches Feld hat, das nicht statisch oder eine Konstante ist, dann betrachtet Usus diese Klasse als einen Hotspot. Dabei wird jede Klasse mit 1 bewertet, die mindestens eines dieser Felder besitzt. Der Schwellwert ist ebenfalls 1. Die Anzahl der betroffenen Klassen wird wie jede andere Metrik im Usus Cockpit ¸ber die Anzahl aller Klassen gemittelt und somit als Prozent dargestellt.
\subsubsection{Pakete mit zyklischen Abh‰ngigkeiten}
F¸r Klassen wurde in Unter-Unterabschnitt \ref{subsubsec:ccd} ein Abh‰ngigkeitsgraph unabh‰ngig vom Paket ermittelt, in dem sich die betrachtete Klasse befindet. Um Pakete mit zyklischen Abh‰ngigkeiten zu identifizieren, m¸ssen alle Klassen-Knoten eines Paket in dem Abh‰ngigkeitsgraph zu einem Paket-Knoten in einem neuen Abh‰ngigkeitsgraph auf Paketebene zusammengefasst werden. Die Kanten zwischen den Klassen werden auf Kanten zwischen den ¸bertragen. Anschlieﬂend kˆnnen alle trivialen Kreise im Paket-Abh‰ngigkeitsgraph entfernt und Zyklen gesucht werden. Heiko Kˆrner beschreibt in seinem Skript \cite{GraphAlgorithms} die beiden Algorithmen \textit{Gegenseitige Erreichbarkeit} und \textit{Starke Zusammenhangskomponenten} f¸r diesen Zweck. Mit den Algorithmen kˆnnen alle starken Zusammenhangskomponenten (engl. \textit{strongly connected components} (SCC)) ermittelt werden. Alle starken Zusammanhangskomponenten, die mehr als eine Paket beinhalten entsprechen dann Paketen, die auf einem Kreis im Abh‰ngigkeitsgraph liegen.
\begin{equation}
	cyclicPackages(pdG) = \sum_{scc\text{ }\in\text{ } \displaystyle SCCs(pdG)}
	\begin{cases}
		| scc |, & \text{wenn }|scc| > 1\\
		0, & \text{sonst}\\
	\end{cases}
\label{eq:packageswithcyclicdependencies}
\end{equation}
\begin{eqnarray*}
pdG&=&\text{Paket-Abh‰ngigkeitsgraph}\\
SCCs(pdG)&=&\text{Menge aller starken Zusammenhangskomponenten in }pdG\\
scc&=&\text{Starke Zusammenhangskomponente als Menge von Paketen}\\
cyclicPackages(pdG)&=&\text{Anzahl aller Pakete in allen starken Zusammenhangskomponenten in }pdG\\
\label{eq:packageswithcyclicdependenciesagenda}
\end{eqnarray*}
Formel \ref{eq:packageswithcyclicdependencies} zeigt dabei die Aufsummierung aller Pakete in nicht-trivialen starken Zusammenhangskomponenten eines Paket-Abh‰ngigkeitsgraph. Abschlieﬂend kann der $cyclicPackages$-Wert durch die Anzahl der betrachteten Pakete dividiert werden, um einen durchschnittlichen Paket-Zyklus-Wert zu bestimmen, der im Usus Cockpit angezeigt wird.




\chapter{Technologie Evaluierung}
Wichtigste Kriterien
\begin{enumerate} 
\item Access to information required to calculate Usus metrics?
\item Is it available for free?
\item Does it support all .NET runtimes?
\end{enumerate}
Wichtige Kriterien
\begin{enumerate} 
\item Does it have external dependencies?
\item Does it work with unresolved references?
\end{enumerate}
Nice To Have Kriterien
\begin{enumerate} 
\item Can it be used for more than C$\#$ only?
\item What is the target? //code or assembly
\item What is the (performance) overhead?
\end{enumerate}


\section{Statische-Code-Analyse-Tools}


\section{FxCop}


\section{Common Compiler Infrastracture}


\section{NRefactory}


\section{Codename "`Roslyn"'}


\section{Zusammenfassung}
Mit Ergebnis aka welche Technologie f¸r die statische Codeanalyse verwendet werden soll.




\chapter{Usus.net Objektmodell}
todo


\section{Struktur}
todo


\section{Metrikberechnung}
todo




\chapter{Visual Studio Erweiterung}
todo




\chapter{Clean Code Unterst¸tzung}
todo


\section{Achievements System}
todo


\section{Fallbeispiel Andrena-Kurs}
todo




\chapter{Code-Qualit‰t Bewertung}
todo


\section{Histogram}
todo


\section{Exponentialverteilungen}
todo


\section{Heuristiken}
todo


\section{Andrena Software Qualit‰ts Index}
todo




\chapter{Zusammenfassung}
todo




\chapter{Fazit}
todo









\bibliography{masterthesis}
\bibliographystyle{alpha}

\end{document}
