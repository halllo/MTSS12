\documentclass[
a4paper, 							% Papierformat
%10pt,								% Schriftgröße (12pt, 11pt (Standard))
%twoside,							% Doppelseiten
titlepage,						% Titelei auf eigener Seite
%normalheadings,			% Überschriften etwas kleiner (smallheadings)
%idxtotoc,						% Index im Inhaltsverzeichnis
%liststotoc,					% Abb.- und Tab.verzeichnis im Inhalt
%bibtotoc,						% Literaturverzeichnis im Inhalt
%leqno,   						% Nummerierung von Gleichungen links
%fleqn,								% Ausgabe von Gleichungen linksbündig
%draft								% überlangen Zeilen in Ausgabe gekennzeichnet
]
{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tipa}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm,includeheadfoot]{geometry}

\begin{document}



\thispagestyle{empty}
\begin{titlepage}
\begin{figure}[t]
	\centering
  \includegraphics[width=80mm]{images/HsKaLogoKlein.png}
	\vspace{2.5cm}
\end{figure}
\begin{center}
\title{Master-Thesis}
\textbf{\huge{Master-Thesis}} \\[0.5cm]
\textbf{Visual Studio Erweiterung zur statischen Code-Analyse} \\[4cm]
\textbf{andrena objetcs ag} \\[0.25cm]
\author{Manuel Naujoks} Manuel Naujoks\\[2.5cm]
Betreut durch \\[0.25cm] 
Prof. Dr. Thomas Fuchß \\[2.5cm]
Bischweier, den \today
\end{center}
\end{titlepage}



\pagenumbering{roman}
\setcounter{page}{1}
\begin{center}\textbf{\large Erklärung}\\[1cm]\end{center}
Hiermit versichere ich, dass ich die vorliegende Arbeit selbstständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe, dass alle Stellen der Arbeit, die wörtlich oder sinngemäß aus anderen Quellen übernommen wurden, als solche kenntlich gemacht sind und dass die Arbeit in gleicher oder ähnlicher Form noch keiner Prüfungsbehörde vorgelegt wurde.
\\[4\baselineskip]
Bischweier, den \today \\
Manuel Naujoks
\newpage



\chapter*{Zusammenfassung}
Im Rahmen dieser Master-Thesis soll eine Visual Studio Erweiterung entwickelt werden, die direktes Entwickler-Feedback anhand von Software-Metriken geben kann. Dabei dient das Plugin Usus für Eclipse als Vorlage, welches bereits existiert. Die zu erstellende Erweiterung soll eine statische Code-Analyse von .NET-Projekten in Visual Stuido 2010 durchführen und für andrena relevante Code-Metriken berechnen können.
\newline
Die zu entwickelnde Erweiterung soll genutzt werden können, um Software-Entwickler aktiv zu unterstützen "`Clean code"' zu schreiben. Eine ähnliche Lösung zu Microsofts Achievements Extension mit Achievements in Bezug auf clean code best practices wäre denkbar. Dazu soll eine Evaluierung anhand von Beispielaufgaben aus einem andrena-Kurs zum Thema Refaktorisierung bearbeitet und die Veränderung in den Metriken entsprechend erfasst und dokumentiert werden.
\newline
Weiterhin soll in einer Metrik-Analyse nach Heuristiken oder Regeln mit statischer Signifikanz gesucht werden, die eventuell guten von schlechtem Code unterscheiden können. Lassen sich hier Muster beziehungsweise Strukturen aufzeigen? Ein Indiz hierfür ist, dass die Metriken oft einer Exponentialverteilung folgen. Dabei soll untersucht werden, ob und wenn möglich wie sich dies auf den Software Qualitäts Index (SQI) von andrena abbilden lässt.
\newpage



\chapter*{Abstract}
Objective of this master thesis is the development of a Visual Studio Extension that is capable of providing direct development feedback based on software metrics. The Eclipse plugin Usus, which already exists, is going to be used as orientation. The extension that is developed shall be able to perform static code analysis of .NET projects in Visual Studio 2010 in order to calculate the code metrics that are relevant for andrena.
\newline
As far as feedback is concerned, the extension shall be able to actively support developers to write "`clean code"'. A similar solution to Microsofts Achievements Extension could likely be found with achievements based on common clean code best practices. Therefore an evaluation with sample exercises of an andrena course on the topic of refactoring is done and the variation in the metrics is detected and documented.
\newline
Another metric analysis is performed in order to find heuristics or rules with static significance, which might be able to distinguish good code from bad code. Are there detectable patterns? One thing might be that metrics often follow an exponential distribution. An analysis shall show whether it is possible and if yes, how this can be mapped to the Software Quality Index (SQI) of andrena.
\newpage




\tableofcontents




\chapter{Einführung}
\pagenumbering{arabic}
\setcounter{page}{1}
todo




\chapter{Grundlagen}
In diesem Kapitel sollen die Grundlagen vermittelt werden, die für ein Verständnis einer mit Quellcode arbeitenden Erweiterung für Visual Studio erforderlich sind. Dazu wird in Abschnitt \ref{sec:oo} zunächst der Begriff der Objektorientierung eingeführt, bevor in Abschnitt \ref{sec:staticcodeanalysis} auf das Konzept der statischen Code-Analyse eingegangen wird. Anschließend wird in Abschnitt \ref{sec:visualstudio} auf das Umfeld der Erweiterung eingegangen, die im Rahmen dieser Master-Thesis entwickelt werden soll. Dabei handelt es sich um das Entwicklungswerkzeug Visual Studio.
In Abschnitt \ref{sec:cleancode} wird abschließend Bezug auf Quellcode, beziehungsweise die Clean Code Prinzipien genommen.


\section{Objektorientierung}
\label{sec:oo}
Die Objektorientierung als Methode ermöglicht laut Benrd Oestereich die hohe Komplexität von Softwaresystemen zu beherrschen \cite{OOSE}. Das ist möglich, da diese Methode die Dinge der realen Welt als Objekte sieht und dadurch die Problemdomäne verständlich und anschaulich macht. Ein objektorientiertes Softwaresystem besteht aus den folgenden vier wesentlichen Komponenten.
\begin{description}
\item[Objekt] kommt aus dem lateinischen von \textit{obicere} und bedeutet "`entgegenhalten"'. Bernd Oestereich beschreibt es als "`Gegenstand der Erkenntnis und Wahrnehmung, des Denkens und Handelns"' und bezieht sich dabei auf das Brockhaus Lexikon.
\item[Klasse] kommt ebenfalls aus dem lateinischen von \textit{classis} und bedeutet "`Aufgebot"'. Damit ist laut Oestereich eine Teilmenge von Objekten der gleichen Struktur gemeint.
\item[Operation] kommt aus dem lateinischen von \textit{operatio} und bedeutet "`Handlung"'. Eine konkrete Aktion, die anhand einer definierten Vorschrift durchgeführt wird bezeichnet Oestereich in diesem Sinne als Operation. Das Verhalten von Objekten wird anhand ihrer Operationen festgelegt.
\item[Attribut] kommt auch aus dem lateinischen von \textit{attributum} und bedeutet "`das Beigefügte"', was einer Eigenschaft oder einem Kennzeichen einer Sache entspricht. Die Daten, die ein Objekt ausmachen, werden anhand von Attributen gespeichert, auf die von den Operationen des Objekts aus zugegriffen werden kann.
\item[Packet] wird von Oestereich als eine Ansammlung von Modellelementen bezeichnet. Dabei sind Modellelemente Klassen oder andere Pakete und dienen der besseren Strukturierung des Systems.
\end{description}
Zusätzlich beschreibt Oerstereich zwei weitere Mittel von objektorientierten Softwaresystemen, die der Abstraktion dienen und die es erlauben irrelevant Dinge wegzulassen.
\begin{description}
\item[Assoziation] kommt aus dem lateinischen von \textit{associare} und bedeutet "`verbinden"'. Nach Oestereich entspricht dies einer \textit{Hat-eine-Beziehung} und gibt an, dass eine Klasse mit einer anderen Klasse zusammenarbeitet.
\item[Vererbung] entspricht einer \textit{Ist-ein-Beziehung} und gibt an, dass eine Klasse das Verhalten und die Struktur einer anderen Klasse erbt oder spezialisiert.
\end{description}
Mit diesen sechs Konzepten kann eine Softwaresystem objektorientiert beschrieben werden.


\section{Statische Code-Analyse}
\label{sec:staticcodeanalysis}
todo


\section{Visual Studio}
\label{sec:visualstudio}
Visual Studio ist eine integrierte Entwicklungsumgebung (IDE) von Microsoft.


\section{Clean Code}
\label{sec:cleancode}
Ein Softwaresystem wird in Form von Quellcode erstellt. Dieser Code wird anschließend kompiliert um eine ausführbares Programm zu erhalten. Robert C. Martin beschreibt Code in seinem Clean Code Buch als Sprache, in der wir die Anforderungen an die Software maschinenlesbar zum Ausdruck bringen \cite{CleanCode}. Weiter beschreibt er in seinem Buch Prinzipien und "`Best Practices"', die das Erstellen von verständlicherem und wartbareren Quellcode unterstützen. Die selben Prinzipien wurden auch von Ralf Westphal und Stefan Lieser aufgegriffen und im Rahmen eines Wertesystems mit sieben Graden vorgestellt \cite{CleanCodeDeveloper}. Martin's Clean Code Buch bleibt auch für Westphal und Lieser die grundlegende Lektüre.
\paragraph{}
Die Prinzipien und Best Practices der Clean Code Bewegung umfassen viele Aspekte, die bereits durch Kent Beck in seinem Buch über die Methodik \textit{Extreme Programming} (XP) \cite{XP} eingeführt wurden. Drei wichtige Bestandteile von XP, die ebenfalls in den Graden des Clean Code Wertesystems von Westphal und Lieser auftreten, sind die folgenden.
\begin{description}
\item[Automatisiertes Testen] ist eine der wichtigsten Praktiken in der Clean Code Bewegung. Nach Robert C. Martin ist es die Aufgabe eines Entwicklers keinen Schaden in einem Softwaresystem anzurichten. Damit meint er Schaden an der Funktionalität und Schaden an der Struktur der Anwendung. Beides kann mit automatisierten Testfällen sichergestellt werden.
\item[Ständiges Refactoring] ist der effektivste Schutz gegen Schaden an der Struktur eines Softwaresystems bedingt durch evolutionäres Wachstum und vielen Anpassungen. Durch Tests kann dabei sichergestellt werden, dass Umstrukturierungen den Funktionsumfang nicht beeinträchtigen. Martin Fowler beschreibt solches Refactoring in seinem Buch \cite{Refactoring}
\item[Schnelle Code Reviews] sind eine weitere Voraussetzung um Clean Code entwickeln zu können. Der entscheidende Punkt ist das Feedback. Je schneller der Entwickler Feedback bekommt um so früher können Probleme im Quellcode erkannt und mit relativ wenig Aufwand korrigiert werden.
\end{description}




\chapter{Usus}
Das Wort \textit{usus} kommt aus dem lateinischen und bedeutet "`das, was üblich ist"'. In diesem Kapitel wird das Usus Plugin für die Java Entwicklungsumgebung Eclipse vorgestellt, sowie auf die Metriken, die es berechnet, eingegangen. Der Bedeutung entsprechend 


\section{Eclipse Plugin}
Das Usus Plugin für Eclipse lässt sich über den Menü-Eintrag \texttt{Help / Install New Software} installieren, indem eine neue Software Site mit der Url \url{http://projectusus.googlecode.com/svn/updates/} hinzugefügt und anschließend \emph{Project Usus} ausgewählt wird. Nach der Installation steht die \emph{Project Usus perspective} zur Verfügung, die die folgenden Fenster enthält.
\begin{description}

\item[Usus Cockpit] In diesem Fenster werden die Usus Metriken angezeigt, die für alle Projekte, die Usus betrachtet, gelten.
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm]{images/usus_cockpit.png}
	\caption{Usus Cockpit zeigt Übersicht über alle Projekte}
	\label{fig:usus_cockpit}
\end{figure}
Die in Abbildung \ref{fig:usus_cockpit} dargestellten Metriken errechnen sich aus der Aggregation der Package-, Klassen- oder Methoden-Eigenschaften.

\item[Usus Info] Dieses Fenster lässt sich im Kontext einer Methode oder einer Klasse öffnen und zeigt Metriken, die anhand der Eigenschaften des Kontextes ermittelt werden können.
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm]{images/usus_info.png}
	\caption{Usus Info zeigt Übersicht über eine Methode oder Klasse}
	\label{fig:usus_info}
\end{figure}
Das in Abbildung \ref{fig:usus_info} gezeigte Info-Fenster lässt sich mit \texttt{Ctrl-U} öffnen und mit \texttt{Esc} wieder schließen.

\item[Usus Hotspots] Dieses Fenster zeigt sogenannte Hotspots, also Stellen im Quellcode, dessen Metriken definierte Grenze oder einen Schwellwert überschreiten. Hotspots lassen sich für jede Metrik definieren, die im Usus Cockpit angezeigt wird.
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm]{images/usus_hotspots.png}
	\caption{Usus Hotspots zeigt die Stellen im Code, die eine besondere Metrikausprägung haben}
	\label{fig:usus_hotspots}
\end{figure}
Das in Abbildung \ref{fig:usus_hotspots} gezeigte Hotspot-Fenster zeigt Hotspots immer nur für eine Metrik an. Der Wechsel zu einer anderen Hotspot-Metrik erfolgt über einen Doppelklick auf die Metrikanzeige im Usus Cockpit.

\item[Usus Histogram] Dieses Fenster zeigt die Verteilung der Metrik-Ausprägungen über alle Projekte, die Usus betrachtet. Die Verteilung lässt sich wie für Usus Hotspots für alle Metriken, die im Usus Cockpit angezeigt werden, definieren.
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm]{images/usus_histogram.png}
	\caption{Usus Histogram zeigt die statistische Verteilung der Ausprägungen der definierten Metrik}
	\label{fig:usus_histogram}
\end{figure}
Das in Abbildung \ref{fig:usus_histogram} gezeigte Histogram-Fenster zeigt die Verteilung der Metrik an, die zuvor über einen Einfachklick im Usus Cockpit markiert wurde.

\item[Usus Class Graph \& Usus Package Graph] Dieses Fenster zeigt die Abhängigkeiten der betrachteten Projekte auf Klassenebene und auf Paketebene. Optional lassen sich nur Pakete anzeigen, die sich in mindestens einem Zyklus von Abhängigkeiten befinden. Auf Klassenebene lassen sich optional nur Kreuzverbindung (?) anzeigen.
\begin{figure}[h]
	\centering
		\includegraphics[width=10cm]{images/usus_graph.png}
	\caption{Usus Graph Fenster zeigen die Abhängigkeiten der Klassen oder Pakete voneinander an}
	\label{fig:usus_graph}
\end{figure}
Das in Abbildung \ref{fig:usus_graph} dargestellte Fenster besteht aus zwei Karteikarten, über die zwischen Klassen- und Paketebene umgeschaltet werden kann.
\end{description}


\section{Metriken}
Das Plugin berechnet die folgenden Metriken. (Zusammenfassung und Erklärung der Metriken mit UML)
\begin{description} 
\item[Average component dependency]
\item[Class size]
\item[Cyclomatic complexity]
\item[Method length]
\item[Number of non-static, non-final public fields]
\item[Packages with cyclic dependencies]
\end{description}




\chapter{Anforderungen}
Was muss gemacht werden?




\chapter{Vorgehensweise}
Meilenstein 1 (Usus.net)
\begin{enumerate} 
\item Evaluierung der geeignetsten Technologie.
\item Implementierung der Code-Analyse zur Berechnung der Metriken.
\item Implementierung der Visual Studio Erweiterung zur Anzeige der Ergebnisse.
\end{enumerate}
Meilenstein 2 (Entwickler-Feedback)
\begin{enumerate} 
\item Evaluierung von Entwickler-Feedback Möglichkeiten
\item Implementierung der Entwickler-Feedback Möglichkeiten
\item Fallbeispiel Andrena-Kurs
\end{enumerate}
Meilenstein 3 (Mustererkennung)
\begin{enumerate} 
\item Evaluierung von Heuristiken in Metrik-Verteilungen
\item Implementierung der Regeln mit statische Signifikanz zur besseren Code-Klassifikation
\item Mapping von Metriken und Verteilungswerte auf den Andrena Software Quality Index
\end{enumerate}




\chapter{Technologie Evaluierung}
Folgende Kriterien:
\begin{enumerate} 
\item What is the target? //code or assembly
\item Access to information required to calculate metrics?
\item Does it work with unresolved references?
\item Can it be hosted in a single executable?
\item Can it be used for more than C$\#$ only?
\item Does it support all .NET runtimes?
\item What is the (performance) overhead?
\end{enumerate}

\section{System.Reflection}

\section{FxCop}

\section{Common Compiler Infrastracture}

\section{NRefactory}

\section{Codename "`Roslyn"'}

\section{Zusammenfassung}
Mit Ergebnis aka welche Technologie für die statische Codeanalyse verwendet werden soll.




\chapter{Metrik-Berechnung}
todo




\chapter{Visual Studio Erweiterung}
todo




\chapter{Entwickler-Feedback}
todo


\section{Achievements System}
todo


\section{Fallbeispiel Andrena-Kurs}
todo




\chapter{Metrik-Analyse}
todo


\section{Heuristiken}
todo


\section{Exponentialverteilungen}
todo


\section{Andrena Software Qualitäts Index}
todo




\chapter{Zusammenfassung}
todo




\chapter{Fazit}
todo









\bibliography{masterthesis}
\bibliographystyle{alpha}

\end{document}
